"Are you serious?" comments aside, from a programming perspective there's a very simple reason: the OpenType spec only affords a glyph address space of one USHORT, so one font can only support 16 bits worth of glyphs, or 65536 glyphs max.
The current version of Unicode, v8 as of this answer, currently contains 120737 assigned code points, or almost twice as many as fit in a modern font. In fact, Unicode hasn't fit in a modern OpenType font since 2001, with the release of Unicode 3.1, which upped the number of code points from  	49259 to 94205.
"So what about font collections?" I hear you ask. Why not use multiple fonts and support all unicode that way? Well now, you've just described Adobe's Source Pro, and Google's Noto (which are the same font). So: "Why isn't there a font that contains all Unicode glyphs?", because that's been technically impossible since 2001. But it's really the wrong question. Are there any font families that support all of Unicode? Yes, there are.
As for the "how hard can it be": a uniform style for all glyphs in Unicode, across 129 scripts, each with their own typesetting rules? Incredibly hard. You may think fonts are just files with pictures for letters, and someone types a letter, that picture shows up: that is not how fonts work, and isn't how fonts have worked since mid 90's. Modern fonts are the gaming equivalent of a game ROM. Sure, it's not much use without the hardware or software to run that ROM on, but all the things that actually matter are in the ROM. Similary, modern fonts contain all the information for typesetting. Not just pictures, they contain the metadata, the metrics, the positioning and substitutions rules for arbitrary sequences, with separate rulesets for each written script that OpenType supports, possible bitmap fallbacks for small-point rendering, hinting instructions on how to properly rasterize vector graphics that are inherently not aligned to any particular pixel grid, and more. A modern font is a ridiculously complex application that a font engine consults to figure out how to typeset sequences of code points.

