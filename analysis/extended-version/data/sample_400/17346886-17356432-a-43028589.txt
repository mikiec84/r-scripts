Nice question!
Several points should be made:

  - First, as I guess you already know (though some readers of the question and this answer may not), your schema document 1 is already legal as it sits.  So you don't need to modify the schema for schema documents in order to make it legal.  If I understand you correctly, however, you want it not just to be valid; you want the variant of it in which element declarations occur without xs:documentation elements, or without ds:added and ds:last_modified attributes, to be invalid.
  - Second, it is possible to modify the XSD schema for XSD schema documents in the way you describe, and it is in principle possible to validate your schema documents against the modified schema for schema documents.
    But schema validators are allowed to have built-in knowledge of some schema components in arbitrary namespaces, and they are required to have built-in knowledge of the XSD namespace.  So it is possible for conforming schema validators to see a request to validate schema document 1, say "Aha, I already know all I need to know about namespace I don't need to read the schema document the user supplied", and then not enforce the additional constraints you have specified.
    Concretely, in my tests, I was able to use Xerces J to validate schema documents against a modified schema for schema documents, but Saxon seemed to ignore the modifications and rule the schema documents valid even when element declarations lacked the required attributes.
  - Similarly, it is not possible, when validating documents against the schemas you write, to require your XSD validators to object to schema documents that don't meet your heightened requirements.
    With those background points out of the way, here is what you need to do.

1.  You do not need to import the ds schema into your schema document 1.  Importing it means that you can add references to the attributes ds:added, etc., to the types you declare in schema document 1 -- that is, it imports it into the schema being defined for the target namespace.  It has no effect on the schema used to validate schema documents (which is a schema for the namespace
2.  You need to create a schema that modifies the standard schema for schema documents, and not just by adding new components but by redefining or overriding components in the existing schema for schema documents.  There are two ways to do this:  using xs:redefine, and (in XSD 1.1) using xs:override.  In XSD 1.1, xs:redefine is deprecated, because its specification has proven to be incomplete and/or inconsistent, and interoperability across processors is poor for some ways of using it.
3.  You need to use an XSD validator to validate your schema documents against your modified schema for schema documents.  As noted above, this may not work with all validators.  If you have trouble making your XSD validator handle the case, you may want to consider writing a Schematron schema to enforce the few constraints you mention, and building Schematron validation into your work flow.  (One of the advantages of Schematron is that validating just a few isolated aspects of a document is quite easy.  That may be a drawback in some situations, but not in this one or in other cases where one wants a little incremental increase in validation.  And if as your user name suggests you are an XSLT users, Schematron is likely to feel quite natural to you.)
    As a test, I've used xs:override to modify the schema for schema documents for XSD 1.1; the schema document is shown below, and the comments will, I hope, make reasonably clear what is going on.  If you have access only to an XSD 1.0 processor, you will need to use xs:redefine instead; some details will change.

