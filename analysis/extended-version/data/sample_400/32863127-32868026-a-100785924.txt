Just in addition to to @torazabur's excellent answer, it is worth pointing out that the examples in that tutorial are not leaks. A leak what happens when a program deletes a reference to something but does not release the memory it consumes.
The last time I remember that JS developers had to really worry about genuine leaks was when Internet Explorer (6 and 7 I think) used separate memory management for the DOM and for JS. Because of this, it was possible to bind an event to a button, destroy the button, and still have the event handler stranded in memory -- forever (or until the browser crashed or was closed by the user). You couldn't trigger the handler or release it after the fact. It just sat on the stack, taking up room. So if you had a long-lived webapp or a webpage that created and destroyed a lot of DOM elements, you had to be super diligent to always unbind events before destroying them.
I've also run into a few annoying leaks in iOS but these were all bugs and were (eventually) patched by Apple.
That said, a good developer needs to keep resource management in mind when writing code. Consider these two constructors:
If you were to create a thousand instances of , the browser would have to allocate an extra gigabyte of memory for all those copies of the huge string. And every time you deleted an instance, you might get some onscreen jankiness when the GC eventually recovered that ram. On the other hand, if you made a thousand instances of , the huge string would be created once and reused by every instance. That is a huge performance boost.
But the advantage of is that the huge string is essentially private. No other code outside of the constructor would be able to access that string directly. Because of that, each instance of could mutate that string as much as it wanted and you'd never have to worry about causing problems for other instances.
On the other hand, the huge string in is out there for anyone to change. Other instances could change it, and any code that shares the same scope as could too.
So in this case, there is a trade-off between resource use and security.

